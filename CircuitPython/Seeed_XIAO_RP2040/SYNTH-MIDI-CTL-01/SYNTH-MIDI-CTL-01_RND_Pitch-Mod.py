# SYNTH-MIDI-CTL-01_RND_Pitch-Mod.py
#
# Generate random pitch and mod CV values
# Speed pot adjusts notes rate from 0.1 secs to 1.1 sec (7 o-clock to 12 o-clock)
# Set speed pot from 12 o-clock to 3 o-clock to stop (set both CVs to 0V)
# Set speed pot from 3 o-clock to exit (used for debugging)

"""
Hardware is based on
HAGIWO "MIDI to CV module for 900 yen - Modular synth self-made"
    https://note.com/solder_state/n/n17e028497ebaHAGIWO
    https://www.youtube.com/watch?v=bHiZhLAntNI
HAGIWO Arduino code
    https://github.com/land-boards/lb-Arduino-Code/blob/master/LBCards/SYNTHS/SYNTHMIDICTL01/SYNTHMIDICTL01.ino
CircuitPython MIDI code - midi_inoutdemo.py from
    \circuitpythonBundles\adafruit-circuitpython-bundle-7.x-mpy-20220611\examples
Adafruit MIDI handler
    https://docs.circuitpython.org/projects/midi/en/latest/index.html
Runs on board (Wiki Page)
    http://land-boards.com/blwiki/index.php?title=SYNTH-MIDI-CTL-01
Differences from HAGIWO build
    Code is Python not Arduino
    HAGIWO runs on Arduino NANO, this runs on XIAO RP2040 (5V vs 3.3V)
XIAO RP2040 Pins
    A0, P26 = CLK_POT
    D1 = Unused
    D2 = SPI_SS
    D3 = Gate (Out)
    D4 = MIDI Clk (Out)
    D5 = SPI_LDAC
    D6/TX - MIDI_Out
    D7/RX = MIDI In
    D8 = SPI_SCK
    D9 = Unused
    D10 = MOSI
XIAO RP2040 CPU
    http://land-boards.com/blwiki/index.php?title=QT_Py_(RP2040_based)#Seeeduino_XIAO_RP2040
    3.3V operation
Starts out with USB MIDI
Use MIDI Editor to send out music over USB
    https://midieditor.org/
Gate output goes on for Note On, off for Note Out
CVs generated by MCP4822 Dual 12-bit D/A

Only plays 1 note at a time on mono synth
HAGIWO code uses 2nd CV as modulation input to the VCO which uses  as control
Pitch Blend adjusts Pitch CV
MIDI clock rate is divide by 24, 12, 6, 3 as determine by CLK Rate pot
"""

import time
import board
import digitalio
import busio
import analogio
# https://docs.circuitpython.org/projects/midi/en/latest/api.html
import usb_midi
import adafruit_midi
import microcontroller
# pylint: disable=unused-import
from adafruit_midi.control_change import ControlChange
from adafruit_midi.pitch_bend import PitchBend
from adafruit_midi.note_off import NoteOff
from adafruit_midi.note_on import NoteOn
from adafruit_midi.program_change import ProgramChange
import math

import random

def setGate(gateVal):
    if gateVal:
        GATE.value = False
    else:
        GATE.value = True

Note0V = 43  # WAS 36 - Adjusted to match the 
Note5V = Note0V + 60  # 5 octaves = 50 semi-s

def handleFirstNoteOn(note,velocity):
    # No standard values for key to CV
    # C2 = 0V in many VCOs (Note 36)
    # Ex: https://doepfer.de/a110.htm
    # C3 = 1V (Note 48)
    # C4 = 2V (Note 60 in MIDIEditor)
    # C5 = 3V(Note 72
    # C6 = 4V (Note 84)
    # C7 = 5V (Mote 96)
    print("First Note On =",note,end='')
    print(" velocity",velocity,end='')
    setGate(True)
    if note < Note0V:  # Lowest note
        notePitchCV = 0
    elif note > Note5V: # Highest note is 82 (can't test since MIDIEditor only goes up to note 71)
        notePitchCV = Note5V
    else:
        notePitchCV = noteToCVTable[note-Note0V]
    print(", Note CV =",notePitchCV,end='')
    voltsVal = (5.0 * notePitchCV) / 4096.0
    print(", volts", voltsVal)
    writeCVD2A(0x3000 + notePitchCV)
    pass

def handleFirstNoteOff(note):
#     print("First Note Off =",note)
    setGate(False)
    writeCVD2A(0x3000)
    pass

def getMIDIClkRate():
    # Observed A/D value: Min = 352, Mac = 65216
    # Arduino has 10-bit range
    # Not sure why CircuitPython has 16-bit values?
    # Pot 7 o-clock to 9 o-clock = 24 (slowest)
    # Pot 9 o-clock to 12 o-clock = 12
    # Pot 12 o-clock to 3 o-clock = 6
    # Pot 3 o-clock to 5 o-clock = 3 (fastest)
    clkSpeed = clkSpeedPotVal.value
#     print("clkSpeed pot val =",clkSpeed)
    if clkSpeed < 9500:
        clkMax = 24
    elif clkSpeed < 29200:
        clkMax = 12
    elif clkSpeed < 53000:
        clkMax = 6
    else:
        clkMax = 3
    return(clkMax)

def setMidiClk(clkValue):
    if clkValue:
        CLK.value = False    # low to turn on
    else:
        CLK.value = True   # high to turn off

def handleMidiClk():
#     print("Clock Message")
    MIDIClkDivisor = getMIDIClkRate()
    if clockCount >= MIDIClkDivisor:
       clockCount = 0
    if clockCount == 1:
        setMidiClk(True)
    else:
        setMidiClk(False)
    
def handleControlChange(control, value):
    # https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2
    if control == 121:
#         print("ControlChange: Reset All Controllers")
        noteOnFlag = False
        writeCVD2A(0)
    elif control == 64:
        if value <= 63:
            print("ControlChange: Damper Pedal off")
        else:
            print("ControlChange: Damper Pedal on")
    elif control == 91:
        print("ControlChange: Effects 1 Depth =",value)
    elif control == 10:
        print("ControlChange: Pan =",value)
    elif control == 7:
        print("ControlChange: Volume =",value)
    elif control == 120:
        print("ControlChange: All Sound Off")
        noteOnFlag = False
        writeCVD2A(0)
    elif control == 123:
        print("ControlChange: All Notes Off")
        noteOnFlag = False
        writeCVD2A(0)
    else:
        print("Other Control change - control =", control, ", value =", value)

valCV0 = 0
valCV1 = 0

def writeCVD2A(outval):
    # print("outval",outval)
    # Lock the bus
    #print("Check lock")
    writeBytes = bytes([((outval >> 8) & 0xff), outval & 0xFF])
    while not spi.try_lock():
        pass
    spi.configure(baudrate=5000000, phase=0, polarity=0)
    cs.value = False
    spi.write(writeBytes)
    cs.value = True
    # Need to unlock bus when done
    spi.unlock()
    lddac.value = False
    microcontroller.delay_us(2)
    lddac.value = True
    
def writeCVVals():
# Test routine sends out ramp vals
#     ch0 = 0x3000
#     ch1 = 0xD000
    for val0 in range(4096):
        outval = val0
        writeCVD2A(outval + 0x3000)
        microcontroller.delay_us(1000)

# Set-up MIDI Clock Speed Pot
clkSpeedPotVal = analogio.AnalogIn(board.A0)

# Set up SPI Chip Select pin
cs = digitalio.DigitalInOut(board.D2)
cs.direction = digitalio.Direction.OUTPUT
cs.value = True

# Create an interface to the SPI hardware bus
spi = busio.SPI(board.SCK, MOSI=board.MOSI)

lddac = digitalio.DigitalInOut(board.D5)
lddac.direction = digitalio.Direction.OUTPUT
lddac.value = True

#  midi setup
#  USB is setup as the input

#  midi channel setup
midi_in_channel = 1
midi_out_channel = 1

# MIDI instance constructor
midi = adafruit_midi.MIDI(
    midi_in=usb_midi.ports[0],
    midi_out=None,
    in_channel=(midi_in_channel - 1),
    out_channel=(midi_out_channel - 1),
    debug=False,
)

GATE = digitalio.DigitalInOut(board.D3)
GATE.direction = digitalio.Direction.OUTPUT
GATE.value = True   # high to turn off

CLK = digitalio.DigitalInOut(board.D4)
CLK.direction = digitalio.Direction.OUTPUT
CLK.value = True    # high to turn off

GATE.value = False    # low to turn on
time.sleep(1)
GATE.value = True   # high to turn off
 
CLK.value = False    # low to turn on
time.sleep(1)
CLK.value = True   # high to turn off

# Turn pot from values of ~0 to ~65536 into log values from ~0 to ~15
def normalizePot():
    clkSpeed = clkSpeedPotVal.value
#    print("Analog pot val -",clkSpeed,end='')
    logSpeed = math.log(clkSpeed,2)
#    print(", log of pot",logSpeed,end='')
    # Normalize pot
    logSpeed -= 8.0
    if logSpeed < 0.0:
       logSpeed = 0.001
#    print(", normalized log of pot",logSpeed,end='')
    microSecDelay = int(1000000.0/logSpeed)
#    print(", Delay",microSecDelay)
    return(microSecDelay)
   

# Send out random pitch and random modulation
# Rate is variable via pots from 0.1 to 1.5 secs
# Note rate is Speed Pot is 7 o-clock to 2 o-clock
# CCW = slowest (~1.5 Hz)
# Output muted when Speed Pot is from 2 o-clock to 3 o-clock
# Exit when Speed Pot is 3 o-clock to 5 o-clock
# Turn pot into log pot so control is smoother
stateVals = ['start','clocking','muting','exiting']
state = 'start'
while clkSpeedPotVal.value < 58000:
    while clkSpeedPotVal.value < 50000:
        if state != 'clocking':
            print("Clocking")
            state = 'clocking'
        normalizePot()
        writeCVD2A(random.randint(0, 4095) + 0x3000) # Pitch
        writeCVD2A(random.randint(0, 4095) + 0xB000)   # Modulation
        setGate(True)
        microcontroller.delay_us(50000)
        loopCount = 0
#        print("Clock Speed Pot =",clkSpeedPotVal.value)
#        print("Note rate =",1000000.0/((50000-clkSpeedPotVal.value)*30+100000),"notes/secs")
#        logSpeed = math.log(clkSpeedPotVal.value,2)
#        print("log of pot",logSpeed)
#         while loopCount < 30:
#             spV = normalizePot()
#             if spV < 0:
#                 spV = 0
#             microcontroller.delay_us(spV)
#             loopCount += 1
        microcontroller.delay_us(normalizePot())
        setGate(False)
        microcontroller.delay_us(50000)  # Gate off for 50 mS between notes
    if state != 'muting':
        print('Muted')
        state = 'muting'
    writeCVD2A(0x3000)
    writeCVD2A(0xB000)
    time.sleep(0.01)
    # print("Clock Speed Pot =",clkSpeedPotVal.value)
    normalizePot()
writeCVD2A(0x3000)
writeCVD2A(0xB000)
normalizePot()
print("Exiting out to Python Shell")
